C({"name": "jQuery.Model", "type": "class", "parent": "../jquery/model/model.js", "comment": "<p>Models wrap an application's data layer.  In large applications, a model is critical for:</p>\n\n<ul>\n<li><p>Encapsulating services so controllers + views don't care where data comes from.</p></li>\n<li><p>Providing helper functions that make manipulating and abstracting raw service data easier.</p></li>\n</ul>\n\n<p>This is done in two ways:</p>\n\n<ul>\n<li><p>Requesting data from and interacting with services</p></li>\n<li><p>Converting or wrapping raw service data into a more useful form.</p></li>\n</ul>\n\n<h2>Basic Use</h2>\n\n<p>The [jQuery.Model] class provides a basic skeleton to organize pieces of your application's data layer.\nFirst, consider doing Ajax <b>without</b> a model.  In our imaginary app, you:</p>\n\n<ul>\n<li>retrieve a list of tasks</li></li>\n<li>display the number of days remaining for each task</li>\n<li>mark tasks as complete after users click them</li>\n</ul>\n\n<p>Let's see how that might look without a model:</p>\n\n<pre><code class='javascript'>$.Controller.extend(\"MyApp.Controllers.Tasks\",{onDocument: true},\n{\n  // get tasks when the page is ready \n  ready: function() {\n    $.get('/tasks.json', this.callback('gotTasks'), 'json')\n  },\n |* \n  * assume json is an array like [{name: \"trash\", due_date: 1247111409283}, ...]\n  */\n gotTasks: function( json ) { \n    for(var i =0; i < json.length; i++){\n      var taskJson = json[i];\n\n      //calculate time remaining\n      var remaininTime = new Date() - new Date(taskJson.due_date);\n\n      //append some html\n      $(\"#tasks\").append(\"&lt;div class='task' taskid='\"+taskJson.id+\"'>\"+\n                          \"&lt;label>\"+taskJson.name+\"&lt;/label>\"+\n                          \"Due Date = \"+remaininTime+\"&lt;/div>\")\n    }\n  },\n  // when a task is complete, get the id, make a request, remove it\n  \".task click\" : function( el ) {\n    $.post('/task_complete',{id: el.attr('data-taskid')}, function(){\n      el.remove();\n    })\n  }\n})</code></pre>\n\n<p>This code might seem fine for right now, but what if:</p>\n\n<ul>\n<li>The service changes?</li>\n<li>Other parts of the app want to calculate <code>remaininTime</code>?</li>\n<li>Other parts of the app want to get tasks?</li></li>\n<li>The same task is represented multiple palces on the page?</li>\n</ul>\n\n<p>The solution is of course a strong model layer.  Lets look at what a\na good model does for a controller before we learn how to make one:</p>\n\n<pre><code class='javascript'>$.Controller.extend(\"MyApp.Controllers.Tasks\",{onDocument: true},\n{\n  load: function() {\n    Task.findAll({},this.callback('list'))\n  },\n  list: function( tasks ) {\n    $(\"#tasks\").html(this.view(tasks))\n  },\n  \".task click\" : function( el ) {\n    el.models()[0].complete(function(){\n      el.remove();\n    });\n  }\n})</code></pre>\n\n<p>In views/tasks/list.ejs</p>\n\n<pre><code class='html'>&lt;% for(var i =0; i &lt; tasks.length; i++){ %>\n&lt;div class='task &lt;%= tasks[i].<b>identity</b>() %>'>\n   &lt;label>&lt;%= tasks[i].name %>&lt;/label>\n   &lt;%= tasks[i].<b>timeRemaining</b>() %>\n&lt;/div>\n&lt;% } %></code></pre>\n\n<p>Isn't that better!  Granted, some of the improvement comes because we used a view, but we've\nalso made our controller completely understandable.  Now lets take a look at the model:</p>\n\n<pre><code class='javascript'>$.Model.extend(\"Task\",\n{\n findAll: function( params,success ) {\n  $.get(\"/tasks.json\", params, this.callback([\"wrapMany\",success]),\"json\");\n }\n},\n{\n timeRemaining: function() {\n  return new Date() - new Date(this.due_date)\n },\n complete: function( success ) {\n  $.get(\"/task_complete\", {id: this.id }, success,\"json\");\n }\n})</code></pre>\n\n<p>There, much better!  Now you have a single place where you can organize Ajax functionality and\nwrap the data that it returned.  Lets go through each bolded item in the controller and view.<br/></p>\n\n<h3>Task.findAll</h3>\n\n<p>The findAll function requests data from \"/tasks.json\".  When the data is returned, it it is run through\nthe \"wrapMany\" function before being passed to the success callback.<br/>\nIf you don't understand how the callback works, you might want to check out \n[jQuery.Model.static.wrapMany wrapMany] and [jQuery.Class.static.callback callback].</p>\n\n<h3>el.models</h3>\n\n<p>[jQuery.fn.models models] is a jQuery helper that returns model instances.  It uses\nthe jQuery's elements' shortNames to find matching model instances.  For example:</p>\n\n<pre><code class='html'>&lt;div class='task task_5'> ... &lt;/div></code></pre>\n\n<p>It knows to return a task with id = 5.</p>\n\n<h3>complete</h3>\n\n<p>This should be pretty obvious.</p>\n\n<h3>identity</h3>\n\n<p>[jQuery.Model.prototype.identity Identity] returns a unique identifier that [jQuery.fn.models] can use\nto retrieve your model instance.</p>\n\n<h3>timeRemaining</h3>\n\n<p>timeRemaining is a good example of wrapping your model's raw data with more useful functionality.</p>\n\n<h2>Validations</h2>\n\n<p>You can validate your model's attributes with another plugin.  See [validation].</p>", "tags": ["core"], "download": "http://jmvcsite.heroku.com/pluginify?plugins[]=jquery/model/model.js", "test": "jquery/model/qunit.html", "plugin": "jquery/model", "children": ["jQuery.Model.static", "jQuery.Model.static.create", "jQuery.Model.static.update", "jQuery.Model.static.destroy", "jQuery.Model.static.findAll", "jQuery.Model.static.findOne", "jQuery.Model.static.attributes", "jQuery.Model.static.defaults", "jQuery.Model.static.wrap", "jQuery.Model.static.wrapMany", "jQuery.Model.static.id", "jQuery.Model.static.addAttr", "jQuery.Model.static.publish", "jQuery.Model.static.guessType", "jQuery.Model.static.convert", "jQuery.Model.prototype", "jQuery.Model.prototype.setup", "jQuery.Model.prototype.update", "jQuery.Model.prototype.errors", "jQuery.Model.prototype.attr", "jQuery.Model.prototype.bind", "jQuery.Model.prototype.unbind", "jQuery.Model.prototype._setProperty", "jQuery.Model.prototype._updateProperty", "jQuery.Model.prototype.attrs", "jQuery.Model.prototype.isNew", "jQuery.Model.prototype.save", "jQuery.Model.prototype.destroy", "jQuery.Model.prototype.identity", "jQuery.Model.prototype.elements", "jQuery.Model.prototype.publish", "jQuery.Model.prototype.created", "jQuery.Model.prototype.updated", "jQuery.Model.prototype.destroyed", "jquery.model.services"]})